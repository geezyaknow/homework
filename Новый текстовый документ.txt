Task 2
Однотабличные запросы
1 Вывести всеми возможными способами имена и фамилии студентов, средний балл которых от 4 до 4.5

SELECT student_name, student_surname, score
FROM task1.student
WHERE score BETWEEN 4 and 4.5
2 Познакомиться с функцией CAST. Вывести при помощи неё студентов заданного курса (использовать Like)

SELECT
student_name, student_surname, group_number
FROM task1.student
WHERE group_number::VARCHAR LIKE '4%'
3 Вывести всех студентов, отсортировать по убыванию номера группы и имени от а до я

SELECT
student_name, student_surname, group_number
FROM task1.student
ORDER BY group_number, student_name
4 Вывести студентов, средний балл которых больше 4 и отсортировать по баллу от большего к меньшему

SELECT
student_name, student_surname, score
FROM task1.student
WHERE score > 4
ORDER BY score DESC
5 Вывести на экран название и риск футбола и хоккея

SELECT hobby_name, risk
FROM task1.hobby
WHERE
hobby_name = 'Football' OR
hobby_name = 'Hockey'
6 Вывести id хобби и id студента которые начали заниматься хобби между двумя заданными датами (выбрать самим) и студенты должны до сих пор заниматься хобби

SELECT hobby_id, student_id, date_start
FROM task1.stud_hobby
WHERE date_start BETWEEN
'2017-01-01'::DATE AND '2018-01-01'::DATE
7 Вывести студентов, средний балл которых больше 4.5 и отсортировать по баллу от большего к меньшему

SELECT student_name, student_surname, score
FROM task1.student
WHERE score > 4.5
ORDER BY score DESC
8 Из запроса №7 вывести несколькими способами на экран только 5 студентов с максимальным баллом

SELECT student_name, student_surname, score
FROM task1.student
WHERE score > 4.5
ORDER BY score DESC
LIMIT 5
9 Выведите хобби и с использованием условного оператора сделайте риск словами

SELECT hobby_name,
CASE
WHEN risk < 2 THEN 'very low'
WHEN risk < 4 THEN 'low'
WHEN risk < 6 THEN 'medium'
WHEN risk < 8 THEN 'high'
ELSE 'very high'
END as risk_str
FROM task1.hobby
10 Вывести 3 хобби с максимальным риском

SELECT hobby_name, risk
FROM task1.hobby
ORDER BY risk DESC
LIMIT 3
Групповые функции
1 Выведите на экран номера групп и количество студентов, обучающихся в них

SELECT group_number, count(student_id)
FROM task1.student
GROUP BY group_number
2 Выведите на экран для каждой группы максимальный средний балл

SELECT group_number, avg(score)::NUMERIC(3, 2)
FROM task1.student
GROUP BY group_number
3 Подсчитать количество студентов с каждой фамилией

SELECT student_surname, count(student_id)
FROM task1.student
GROUP BY student_surname
4 Подсчитать студентов, которые родились в каждом году (пока не актуально)

SELECT
extract (YEAR FROM date_birth) AS year_birth,
count(student_id)
FROM task1.student
GROUP BY year_birth
5 Для студентов каждого курса подсчитать средний балл

SELECT
(group_number / 1000)::NUMERIC(3, 2) AS n_curse,
avg(score)
FROM task1.student
GROUP BY n_curse
6 Для студентов заданного курса вывести один номер групп с максимальным средним баллом

SELECT
s.group_number
FROM task1.student s
WHERE floor(s.group_number / 1000) = 2
GROUP BY s.group_number
ORDER BY avg(s.score) DESC
LIMIT 1
7 Для каждой группы подсчитать средний балл, вывести на экран только те номера групп и их средний балл, в которых он менее или равен 3.5. Отсортировать по от меньшего среднего балла к большему.

SELECT
s.group_number,
avg(score)::NUMERIC(3, 2) AS avg_score
FROM task1.student s
GROUP BY s.group_number
HAVING avg(score) >= 3.5
ORDER BY avg_score DESC
8 Для каждой группы в одном запросе вывести количество студентов, максимальный балл в группе, средний балл в группе, минимальный балл в группе

SELECT
group_number, count(student_id) as student_count,
min(score) AS min_score, max(score) as max_score,
avg(score)::NUMERIC(3, 2) as avg_score
FROM task1.student
GROUP BY group_number
9 Вывести студента/ов, который/ые имеют наибольший балл в заданной группе

SELECT
student_name, student_surname, group_number, score
FROM task1.student
WHERE (group_number, score) IN (
SELECT group_number, max(score)
FROM task1.student
GROUP BY group_number
) AND group_number = 2282
10 Аналогично 9 заданию, но вывести в одном запросе для каждой группы студента с максимальным баллом.

SELECT
DISTINCT ON (group_number)
student_name, student_surname, group_number, score
FROM task1.student
ORDER BY group_number, score DESC
Многотабличные запросы
+1 Вывести все имена и фамилии студентов, и название хобби, которым занимается этот студент.

SELECT s.student_name, s.student_surname, h.hobby_name
FROM task1.stud_hobby sh
INNER JOIN task1.student s
ON s.student_id = sh.student_id
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id
+2 Вывести информацию о студенте, занимающимся хобби самое продолжительное время.

SELECT
s.student_name, s.student_surname,
h.hobby_name
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id
ORDER BY date_start
LIMIT 1
+3 Вывести имя, фамилию, номер зачетки и дату рождения для студентов, средний балл которых выше среднего, а сумма риска всех хобби, которыми он занимается в данный момент, больше 0.9.

SELECT
s.student_id,
s.student_name, s.student_surname,
s.date_birth
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id
WHERE s.score > (
SELECT avg(score)
FROM task1.student
)
GROUP BY s.student_id
HAVING sum(h.risk) > .9
+4 Вывести фамилию, имя, зачетку, дату рождения, название хобби и длительность в месяцах, для всех завершенных хобби.

SELECT s.student_id,
s.student_name, s.student_surname,
s.date_birth, h.hobby_name,
(date_part('year', sh.date_finish) -
date_part('year', sh.date_start)) * 12 +
date_part('month', sh.date_finish) -
date_part('month', sh.date_start) +
CASE
WHEN
date_part('day', sh.date_finish) -
date_part('day', sh.date_start) < 0
THEN -1
ELSE 0
END
AS full_passed_mounth
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NOT NULL
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id
5 Вывести фамилию, имя, зачетку, дату рождения студентов, которым исполнилось N полных лет на текущую дату, и которые имеют более 1 действующего хобби.

По сути полный год - это просто достать год из разницы 2-х дат и нет необходимости усложнять и делать отдельный WITH, т.е.

SELECT s.surname, s.name, s.id, s.date_birth
FROM student s
INNER JOIN student_hobby sh ON s.id = sh.student_id
WHERE extract(year from age(now(), s.date_birth)) >= 21
AND date_finish IS NULL
GROUP BY s.id
HAVING count(*) > 1
WITH student_years AS (
SELECT s.student_id,
floor((
(
date_part('year', CURRENT_DATE) -
date_part('year', s.date_birth)
) * 12 +
date_part('month', CURRENT_DATE) -
date_part('month', s.date_birth) +
CASE
WHEN
date_part('day', CURRENT_DATE) -
date_part('day', s.date_birth) < 0
THEN -1
ELSE 0
END
) / 12
) AS full_passed_years
FROM task1.student s
)
SELECT
s.student_id, s.student_name,
s.student_surname, s.date_birth
FROM task1.student AS s
INNER JOIN student_years sy
ON s.student_id = sy.student_id
INNER JOIN task1.stud_hobby sh
ON s.student_id = sh.student_id AND
sh.date_finish IS NOT NULL
WHERE sy.full_passed_years >= 21
GROUP BY s.student_id, sy.full_passed_years
HAVING count(sh.hobby_id) > 1;
+6 Найти средний балл в каждой группе, учитывая только баллы студентов, которые имеют хотя бы одно действующее хобби.

SELECT s.group_number, avg(s.score)::NUMERIC(3, 2)
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON s.student_id = sh.student_id AND
sh.date_finish IS NOT NULL
GROUP BY s.group_number
+7 Найти название, риск, длительность в месяцах самого продолжительного хобби из дейст
• id — World's shortest URL shortener
home.s.id
вующих, указав номер зачетки студента и номер его группы.

SELECT s.student_id,
s.student_name, s.student_surname,
h.hobby_name, h.risk,
(date_part('year', CURRENT_DATE) -
date_part('year', sh.date_start)) * 12 +
date_part('month', CURRENT_DATE) -
date_part('month', sh.date_start) +
CASE
WHEN
date_part('day', CURRENT_DATE) -
date_part('day', sh.date_start) < 0
THEN -1
ELSE 0
END
AS full_passed_mounth
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON s.student_id = sh.student_id AND
sh.date_finish IS NULL
INNER JOIN task1.hobby h
ON sh.hobby_id = h.hobby_id
ORDER BY sh.date_start
LIMIT 1
+8 Найти все хобби, которыми увлекаются студенты, имеющие максимальный балл.

SELECT h.hobby_name
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id
INNER JOIN task1.hobby h
ON sh.hobby_id = h.hobby_id
WHERE s.score = (
SELECT max(score)
FROM task1.student
)
+9 Найти все действующие хобби, которыми увлекаются троечники 2-го курса.

SELECT DISTINCT h.hobby_name
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id
INNER JOIN task1.hobby h
ON sh.hobby_id = h.hobby_id
WHERE floor(s.group_number / 1000) = 2
10 Найти номера курсов, на которых более 50% студентов имеют более одного действующего хобби.

SELECT
floor(s.group_number / 1000) AS course,
count(CASE WHEN s.active_hobbies > 1 THEN 1 END) *
1.0 / count(s.student_id),
count(s.student_id),
count(CASE WHEN s.active_hobbies > 1 THEN 1 END)
FROM (
— students with number of active hobbies
SELECT
s.*, count(sh.hobby_id) AS active_hobbies
FROM task1.student s
LEFT JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL
GROUP BY s.student_id
) AS s
GROUP BY course
HAVING
count(CASE WHEN s.active_hobbies > 1 THEN 1 END) *
1.0 / count(s.student_id) > .5;
11 Вывести номера групп, в которых не менее 60% студентов имеют балл не ниже 4. +в последних версиях pg можно использовать filter вместо CASE внутри COUNT

SELECT
s.group_number,
count(CASE WHEN s.score >= 4 THEN 1 END) AS active_student,
count(s.student_id) AS total_student
FROM task1.student s
GROUP BY s.group_number
HAVING (
count(CASE WHEN s.score >= 4 THEN 1 END)
* 1.0 / count(s. student_id)
) > .6
+12 Для каждого курса подсчитать количество различных действующих хобби на курсе.

WITH uniq_hobby_by_course AS (
SELECT
DISTINCT ON ((sh.hobby_id, floor(s.group_number / 1000)))
floor(s.group_number / 1000) as course,
sh.hobby_id
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NOT NULL
)
SELECT course, count(hobby_id)
FROM uniq_hobby_by_course
GROUP BY course
-( Не имеющих хобби!)13 Вывести номер зачётки, фамилию и имя, дату рождения и номер курса для всех отличников, не имеющих хобби. Отсортировать данные по возрастанию в пределах курса по убыванию даты рождения.

SELECT
floor(s.group_number / 1000) AS course,
s.group_number ,s.student_id,
s.student_name, s.student_surname,
s.date_birth, s.score
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL
WHERE s.score > 4.5
GROUP BY s.student_id
ORDER BY
floor(s.group_number / 1000),
s.date_birth DESC
+14 Создать представление, в котором отображается вся информация о студентах, которые продолжают заниматься хобби в данный момент и занимаются им как минимум 5 лет.

CREATE OR REPLACE VIEW task2.active_students AS
SELECT s.*
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL
AND
DATE_PART(
'year',
AGE(CURRENT_DATE, sh.date_start)
) >= 3
GROUP BY s.student_id;

ALTER TABLE task2.active_students
OWNER TO gamyrkin;
+15 Для каждого хобби вывести количество людей, которые им занимаются.

SELECT h.hobby_name, count(sh.stud_hobby_id)
FROM
task1.stud_hobby sh
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id AND
sh.date_finish IS NULL
GROUP BY h.hobby_id
+16 Вывести ИД самого популярного хобби.

SELECT sh.hobby_id, count(sh.stud_hobby_id)
FROM task1.stud_hobby sh
WHERE sh.date_finish IS NULL
GROUP BY sh.hobby_id
ORDER BY count(sh.stud_hobby_id) DESC
LIMIT 1
+( но ещё лучше создать 16 как представление и использовать его в этом запросе :) 17 Вывести всю информацию о студентах, занимающихся самым популярным хобби.

SELECT s.*
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL AND
sh.hobby_id = (
SELECT sh.hobby_id
FROM task1.stud_hobby sh
WHERE sh.date_finish IS NULL
GROUP BY sh.hobby_id
ORDER BY count(sh.stud_hobby_id) DESC
LIMIT 1
)
18 Вывести ИД 3х хобби с максимальным риском.

SELECT h.hobby_id
FROM task1.hobby h
ORDER BY h.risk DESC
LIMIT 3
19 Вывести 10 студентов, которые занимаются одним (или несколькими) хобби самое продолжительно время.

SELECT s.*
FROM task1.student s
WHERE s.student_id IN (
SELECT sh.student_id
FROM task1.stud_hobby sh
WHERE sh.date_finish IS NULL
GROUP BY sh.student_id
ORDER BY max(CURRENT_DATE - sh.date_start) DESC
LIMIT 10
)
20 Вывести номера групп (без повторений), в которых учатся студенты из предыдущего запроса.

SELECT DISTINCT s.group_number
FROM task1.student s
WHERE s.student_id IN (
SELECT sh.student_id
FROM task1.stud_hobby sh
WHERE sh.date_finish IS NULL
GROUP BY sh.student_id
ORDER BY max(CURRENT_DATE - sh.date_start) DESC
LIMIT 10
)
21 Создать представление, которое выводит номер зачетки, имя и фамилию студентов, отсортированных по убыванию среднего балла.

CREATE OR REPLACE VIEW task2.top_by_score_student AS
SELECT s.student_id,
s.student_name, s.student_surname
FROM task1.student s
ORDER BY s.score DESC;

ALTER TABLE task2.top_by_score_student
OWNER TO rahmatulaev;

SELECT s.*
FROM task2.top_by_score_student s
22 Представление: найти каждое популярное хобби на каждом курсе.

CREATE OR REPLACE VIEW task2.top_hobby_by_course AS
SELECT
DISTINCT ON (course_number)
floor(s.group_number / 1000) as course_number,
sh.hobby_id, count(sh.stud_hobby_id)
FROM task1.stud_hobby sh
INNER JOIN task1.student s
ON s.student_id = sh.student_id
WHERE sh.date_finish IS NULL
GROUP BY course_number, sh.hobby_id
ORDER BY course_number, count(sh.stud_hobby_id) DESC
;

ALTER TABLE task2.top_hobby_by_course
OWNER TO rahmatulaev;
23 Представление: найти хобби с максимальным риском среди самых популярных хобби на 2 курсе.

CREATE OR REPLACE VIEW task2.top_danger_by_top_hobby_by_course AS
SELECT
DISTINCT ON (thbc.course_number)
thbc.course_number, thbc.hobby_id
FROM task2.top_hobby_by_course thbc
INNER JOIN task1.hobby h
ON h.hobby_id = thbc.hobby_id
ORDER BY thbc.course_number, h.risk DESC
;

ALTER TABLE task2.top_danger_by_top_hobby_by_course
OWNER TO rahmatulaev;
24 Представление: для каждого курса подсчитать количество студентов на курсе и количество отличников.

CREATE OR REPLACE VIEW task2.excellent_student_by_course AS
SELECT
floor(s.group_number / 1000) AS course,
count(s.score) AS total_student,
count(CASE WHEN s.score > 4.5 THEN 1 END) AS excellent_student
FROM task1.student s
GROUP BY course
ORDER BY course
;

ALTER TABLE task2.excellent_student_by_course
OWNER TO rahmatulaev;
25 Представление: самое популярное хобби среди всех студентов.

CREATE OR REPLACE VIEW task2.top_hobby AS
SELECT
sh.hobby_id, count(sh.student_id)
FROM task1.stud_hobby sh
GROUP BY sh.hobby_id
ORDER BY sh.count DESC
LIMIT 1
;

ALTER TABLE task2.top_hobby
OWNER TO rahmatulaev;
26 Создать обновляемое представление.

CREATE OR REPLACE VIEW task2.updatable_student_view AS
SELECT
s.student_name, s.student_surname,
s.group_number, s.score, s.date_birth
FROM task1.student s
WITH CHECK OPTION
;

ALTER TABLE task2.updatable_student_view
OWNER TO rahmatulaev;
27 Для каждой буквы алфавита из имени найти максимальный, средний и минимальный балл. (Т.е. среди всех студентов, чьё имя начинается на А (Алексей, Алина, Артур, Анджела) найти то, что указано в задании. Вывести на экран тех, максимальный балл которых больше 3.6

SELECT
UPPER(substr(s.student_name, 1, 1))
AS first_letter,
min(s.score) AS min_score,
avg(s.score)::NUMERIC(3, 2) AS avg_score,
max(s.score) AS max_score
FROM task1.student s
GROUP BY first_letter
ORDER BY first_letter;
28 Для каждой фамилии на курсе вывести максимальный и минимальный средний балл. (Например, в университете учатся 4 Иванова (1-2-3-4). 1-2-3 учатся на 2 курсе и имеют средний балл 4.1, 4, 3.8 соответственно, а 4 Иванов учится на 3 курсе и имеет балл 4.5. На экране должно быть следующее: 2 Иванов 4.1 3.8 3 Иванов 4.5 4.5

SELECT
floor(s.group_number / 1000) AS course,
s.student_surname,
min(s.score) AS min_score,
avg(s.score)::NUMERIC(3, 2) AS avg_score,
max(s.score) AS max_score
FROM task1.student s
GROUP BY
course, s.student_surname
ORDER BY
s.student_surname, course;
29 Для каждого года рождения подсчитать количество хобби, которыми занимаются или занимались студенты.

SELECT
extract (YEAR FROM s.date_birth)
AS year_birth,
count(sh.hobby_id)
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON s.student_id = sh.student_id
GROUP BY extract (YEAR FROM s.date_birth);
30 Для каждой буквы алфавита в имени найти максимальный и минимальный риск хобби.

SELECT
substr(s.student_name, 1, 1)
AS first_name_letter,
min(h.risk), max(h.risk)
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id
GROUP BY first_name_letter
ORDER BY first_name_letter;
31 Для каждого месяца из даты рождения вывести средний балл студентов, которые занимаются хобби с названием «Футбол»

SELECT
extract (MONTH FROM s.date_birth)
AS month_birth,
avg(s.score)::NUMERIC(3, 2)
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id AND
h.hobby_name = 'Football'
GROUP BY month_birth
ORDER BY month_birth;
32 Вывести информацию о студентах, которые занимались или занимаются хотя бы 1 хобби в следующем формате: Имя: Иван, фамилия: Иванов, группа: 1234

SELECT
'Name: ' || s.student_name,
'Surname: ' || s.student_surname,
'Group: ' || s.group_number
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id AND
sh.date_finish IS NULL;
33 Найдите в фамилии в каком по счёту символа встречается «ов». Если 0 (т.е. не встречается, то выведите на экран «не найдено».

SELECT
s.student_id,
CASE
WHEN position('on' in s.student_name) = 0
THEN 'Not found'
ELSE position('on' in s.student_name)::VARCHAR
END
FROM task1.student s;
34 Дополните фамилию справа символом # до 10 символов.

SELECT
s.student_id,
s.student_surname ||
repeat('#', 10 - LENGTH(s.student_surname)) AS
student_surname
FROM task1.student s
35 При помощи функции удалите все символы # из предыдущего запроса.

SELECT
s.student_id,
regexp_replace(
s.student_surname,
'#*$', ''
)
FROM (
SELECT
s.student_id,
s.student_surname ||
repeat('#', 10 - LENGTH(s.student_surname)) AS
student_surname
FROM task1.student s
) s
36 Выведите на экран сколько дней в апреле 2018 года.

SELECT '2018-05-01'::DATE - '2018-04-01'::DATE;
37 Выведите на экран какого числа будет ближайшая суббота.

SELECT
CURRENT_DATE + 1 +
mod((12 - extract (ISODOW FROM CURRENT_DATE))::INT, 7)
AS date_nex_sat;
38 Выведите на экран век, а также какая сейчас неделя года и день года.

SELECT
extract (CENTURY FROM CURRENT_DATE)
AS cur_century,
extract (WEEK FROM CURRENT_DATE)
AS cur_week_of_year,
extract (DOY FROM CURRENT_DATE)
AS cur_day_of_year
39 Выведите всех студентов, которые занимались или занимаются хотя бы 1 хобби. Выведите на экран Имя, Фамилию, Названию хобби, а также надпись «занимается», если студент продолжает заниматься хобби в данный момент или «закончил», если уже не занимает.

SELECT
s.student_name,
s.student_surname,
h.hobby_name,
CASE
WHEN sh.date_finish IS NULL
THEN 'Doing'
ELSE 'Finished'
END AS hobby_state
FROM task1.student s
INNER JOIN task1.stud_hobby sh
ON sh.student_id = s.student_id
INNER JOIN task1.hobby h
ON h.hobby_id = sh.hobby_id
40 Для каждой группы вывести сколько студентов учится на 5,4,3,2. Использовать обычное математическое округление. Итоговый результат должен выглядеть примерно в таком виде:

SELECT
s.group_number,
count(CASE WHEN round(s.score) = 2 THEN 1 END) AS _2,
count(CASE WHEN round(s.score) = 3 THEN 1 END) AS _3,
count(CASE WHEN round(s.score) = 4 THEN 1 END) AS _4,
count(CASE WHEN round(s.score) = 5 THEN 1 END) AS _5
FROM task1.student s
GROUP BY group_number